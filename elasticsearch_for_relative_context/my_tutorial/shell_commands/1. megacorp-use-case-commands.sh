## All of the below are executed on kibana dev tools console
## The below commands are for the use case of megacorp
# http://192.168.0.111:5601/app/dev_tools#/console

PUT /megacorp

POST /megacorp/_doc
{
    "id": 1,
    "type": "employee",
    "first_name" : "John",
    "last_name" :  "Smith",
    "age" :        25,
    "about" :      "I love to go rock climbing",
    "interests": [ "sports", "music" ]
}

POST /megacorp/_doc
{
    "id": 2,
    "type": "employee",
    "first_name" :  "Jane",
    "last_name" :   "Smith",
    "age" :         32,
    "about" :       "I like to collect rock albums",
    "interests":    [ "music" ]
}

POST /megacorp/_doc
{
    "id": 3,
    "type": "employee",
    "first_name" :  "Douglas",
    "last_name" :   "Fir",
    "age" :         35,
    "about":        "I like to build cabinets",
    "interests":    [ "forestry" ]
}

GET /megacorp/_mapping


GET /megacorp/_doc/DXxZ3JEBOmmSC0uoyg14 # This is the _id of the document (automatically generated by Elasticsearch)

GET /megacorp/_source/DXxZ3JEBOmmSC0uoyg14 # Get _source field i.e. the original document input

GET /megacorp/_search

GET /megacorp/_search
{
    "query": {
        "match": {
            "last_name": "Smith"
        }
    }
}

HEAD /megacorp/_source/DXxZ3JEBOmmSC0uoyg14 # Check if document exists

# STORED FIELDS
# stored_fields Works only at the index creation time. If already created, it will not work.
# _source filtering or docvalue_fields are more appropriate for retrieving specific fields in modern versions of Elasticsearch. 
PUT megacorp_new
{
   "mappings": {
       "properties": {
          "age": {
             "type": "integer",
             "store": false
          }
       }
   }
}

POST /megacorp_new/_doc
{
    "id": 1,
    "type": "employee",
    "first_name" : "John",
    "last_name" :  "Smith",
    "age" :        25,
    "new_field":   "I am a new field",
    "about" :      "I love to go rock climbing",
    "interests": [ "sports", "music" ]
}

GET /megacorp_new/_source/E3yD3JEBOmmSC0uoOg2R?stored_fields=age # should not return or exception

# SOURCE FILTERING
GET megacorp/_source/DXxZ3JEBOmmSC0uoyg14/?_source_includes=last_name,first_name # Include only these fields
GET megacorp/_source/DXxZ3JEBOmmSC0uoyg14/?_source_includes=last_name,first_name&_source_excludes=about # Exclude about field

# UPDATE MAPPING FOR EXISTING INDEX - Results in exception
# You cannot directly modify the mapping of existing fields in an index
# To change existing field mappings, you need to:
#   - Create a new index with the updated mapping
#   - Reindex the data from the old index to the new one
#   - Update any aliases to point to the new index
# You can add new fields though
PUT /megacorp
{
    "mappings": {
      "properties": {
        "last_name": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "text",
              "ignore_above": 256
            }
          }
        }
      }
}
}

# SEARCH LITE
GET /megacorp/_search
GET /megacorp/_search?q=last_name:Smith

# For one, we are no longer using query-string parameters, but instead a request body.
# https://www.elastic.co/guide/en/elasticsearch/guide/2.x/_search_with_query_dsl.html

# QUERY DSL
# Lite search has it own limitations
GET /megacorp/_search
{
    "query" : {
        "match" : {
            "last_name" : "Smith"
        }
    }
}

GET /megacorp/_search
{
    "query" : {
        "match_phrase" : {
            "last_name" : "smith"
        }
    }
}

GET /megacorp/_search
{
    "query" : {
        "match" : {
            "last_name" : "mith"
        }
    }
}

GET /megacorp/_search
{
    "query" : {
        "bool" : {
            "must" : {
                "match" : {
                    "last_name" : "smith" 
                }
            },
            "filter" : {
                "range" : {
                    "age" : { "gt" : 30 } 
                }
            }
        }
    }
}

# Full-Text Search
GET /megacorp/_search
{
    "query" : {
        "match" : {
            "about" : "rock climbing"
        }
    }
}

#Phrase Search
GET /megacorp/_search
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    }
}

#Highlighting - "I love to go <em>rock climbing</em>"
GET /megacorp/_search
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    },
    "highlight": {
        "fields" : {
            "about" : {}
        }
    }
}

# Aggregations
#     "caused_by": {
# "type": "illegal_argument_exception",
# "reason": "Fielddata is disabled on [interests] in [megacorp]. 
# Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. 
# Please use a keyword field instead. Alternatively, set fielddata=true on [interests] in order to load field data by uninverting the inverted index. Note that this can use significant memory.",
# }

GET /megacorp/_search
{
  "aggs": {
    "all_interests": {
      "terms": { "field": "interests" }
    }
  }
}

# Instead do this
PUT /megacorp_new
{
    "mappings": {
      "properties": {
        "interests": {
          "type": "keyword"
        }
      }
}
}

POST /megacorp_new/_doc
{
    "id": 1,
    "type": "employee",
    "first_name" : "John",
    "last_name" :  "Smith",
    "age" :        25,
    "about" :      "I love to go rock climbing",
    "interests": [ "sports", "music" ]
}

POST /megacorp_new/_doc
{
    "id": 2,
    "type": "employee",
    "first_name" :  "Jane",
    "last_name" :   "Smith",
    "age" :         32,
    "about" :       "I like to collect rock albums",
    "interests":    [ "music" ]
}

POST /megacorp_new/_doc
{
    "id": 3,
    "type": "employee",
    "first_name" :  "Douglas",
    "last_name" :   "Fir",
    "age" :         35,
    "about":        "I like to build cabinets",
    "interests":    [ "forestry" ]
}

GET /megacorp_new/_search
{
  "aggs": {
    "all_interests": {
      "terms": { "field": "interests" }
    }
  }
}

GET /megacorp_new/_search
{
  "aggs": {
    "all_interests": {
      "terms": { "field": "interests" }
    }
  }
}

## Output to see

"aggregations": {
"all_interests": {
    "doc_count_error_upper_bound": 0,
    "sum_other_doc_count": 0,
    "buckets": [
    {
        "key": "music",
        "doc_count": 2
    },
    {
        "key": "forestry",
        "doc_count": 1
    },
    {
        "key": "sports",
        "doc_count": 1
    }
    ]
}
}

# We can see that two employees are interested in music, one in forestry, and one in sports. 
# These aggregations are not precalculated; they are generated on the fly from the documents that match the current query. 
# If we want to know the popular interests of people called Smith, we can just add the appropriate query into the mix

GET /megacorp_new/_search
{
  "query": {
    "match": {
      "last_name": "smith"
    }
  },
  "aggs": {
    "all_interests": {
      "terms": {
        "field": "interests"
      }
    }
  }
}

# Aggregations allow hierarchical rollups too. 
# For example, letâ€™s find the average age of employees who share a particular interest:

GET /megacorp/_search
{
    "aggs" : {
        "all_interests" : {
            "terms" : { "field" : "interests" },
            "aggs" : {
                "avg_age" : {
                    "avg" : { "field" : "age" }
                }
            }
        }
    }
}

## Cluster Health
# green: All primary and replica shards are active. 
# yellow: All primary shards are active, but not all replica shards are active. (so single node cluster will always be yellow). As soon as you start adding more nodes, the cluster will turn green.
# red: Not all primary shards are active.

# Indices vs. Shards
# An index is a collection of documents that have somewhat similar characteristics.
# A shard is a low-level worker unit that holds just a slice of all the data in the index.

# By default, indices are assigned five primary shards

GET /_cluster/health

GET /_cat/indices?v

# Index Versus Shard
# To add to the confusion, a Lucene index is what we call a shard in Elasticsearch, 
# while an index in Elasticsearch is a collection of shards. When Elasticsearch searches an index, 
# it sends the query out to a copy of every shard (Lucene index) that belongs to the index, 
# and then reduces the per-shards results to a global result set

# Shards are how Elasticsearch distributes data around your cluster. 
# Think of shards as containers for data. Documents are stored in shards, 
# and shards are allocated to nodes in your cluster. As your cluster grows or shrinks, 
# Elasticsearch will automatically migrate shards between nodes so that the cluster remains balanced.

# A shard can be either a primary shard or a replica shard. 
# Each document in your index belongs to a single primary shard, 
# so the number of primary shards that you have determines the maximum amount of data that your index can hold

#THE NUMBER OF PRIMARY SHARDS IN AN INDEX IS FIXED AT THE TIME THAT AN INDEX IS CREATED, 
#BUT THE NUMBER OF REPLICA SHARDS CAN BE CHANGED AT ANY TIME.

# refresh API
# By default, every shard is refreshed automatically once every second. 
# This is why we say that Elasticsearch has near real-time search: document changes are not visible to search immediately, 
# but will become visible within 1 second.
# It is NOT advisable to do manual refresh in production

POST /_refresh 
POST /megacorp/_refresh 

# Your use case might allow refresh at a lower rate
PUT /megacorp/_settings
{
  "settings": {
    "refresh_interval": "30s" 
  }
}




